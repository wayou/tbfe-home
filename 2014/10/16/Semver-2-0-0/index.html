<!DOCTYPE HTML><html><head><meta charset="utf-8"><title>Semver 2.0.0 | JSBear</title><meta name="author" content="JSBear Team"><meta name="description" content="我们是一群搞前端的熊孩子:()"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Semver 2.0.0"><meta property="og:site_name" content="JSBear"><meta property="og:image" content="undefined"><link href="/tbfe-home/favicon.png" rel="icon"><link rel="stylesheet" href="/tbfe-home/css/jquery.tocify.css" media="screen" type="text/css"><link rel="stylesheet" href="/tbfe-home/css/bootstrap.min.css" media="screen" type="text/css"><link rel="stylesheet" href="/tbfe-home/material/css/ripples.css" media="screen" type="text/css"><link rel="stylesheet" href="/tbfe-home/material/css/material.css" media="screen" type="text/css"><link rel="stylesheet" href="/tbfe-home/css/font-awesome.css" media="screen" type="text/css"><link rel="stylesheet" href="/tbfe-home/css/style.css" media="screen" type="text/css"><link rel="stylesheet" href="/tbfe-home/css/highlight.light.css" media="screen" type="text/css"><link rel="stylesheet" href="/tbfe-home/css/google-fonts.css" media="screen" type="text/css"><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><script src="/tbfe-home/js/jquery-2.0.3.min.js"></script></head><body><nav id="main-nav" class="navbar navbar-default" role="navigation"><div class="container"><button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/tbfe-home/">JSBear</a><div class="collapse navbar-collapse nav-menu"><ul class="nav navbar-nav navbar-right"><li><a href="/tbfe-home/"><i class="fa fa-home"></i>首页</a></li><li><a href="/tbfe-home/archives"><i class="fa fa-list"></i>存档</a></li><li><a href="/tbfe-home/categories"><i class="fa fa-folder"></i>分类</a></li><li><a href="/tbfe-home/about"><i class="fa fa-info-circle"></i>关于</a></li><li><a href="/tbfe-home/atom.xml"><i class="fa fa-rss"></i>RSS</a></li></ul></div></div></nav><div class="clearfix"></div><div class="container"><div class="content"><div class="page-header"><h1>Semver 2.0.0</h1></div><div class="row post"><div class="col-md-9"><div class="mypage"><div class="row widget-wrapper"><div class="post-meta-item"><i class="fa fa-clock-o"></i> <span class="post-time">2014-10-16 15:36:47</span></div><div class="post-meta-item"><i class="fa fa-user" title="作者"></i> <span>JSBear Team</span></div><div class="post-meta-item"><i class="fa fa-folder"></i> <a class="label label-success" href="/tbfe-home/categories/doc/">doc</a></div><div class="post-meta-item"><i class="fa fa-tags"></i> <a class="label label-warning" href="/tbfe-home/tags/semver/">semver</a> <a class="label label-warning" href="/tbfe-home/tags/dev/">dev</a></div></div><h1 id="Summary">Summary</h1><p>Given a version number MAJOR.MINOR.PATCH, increment the:</p><ol><li>MAJOR version when you make incompatible API changes,</li><li>MINOR version when you add functionality in a backwards-compatible<br>manner, and</li><li>PATCH version when you make backwards-compatible bug fixes.</li></ol><p>Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.<br><a id="more"></a></p><h1 id="Introduction">Introduction</h1><p>In the world of software management there exists a dread place called<br>“dependency hell.” The bigger your system grows and the more packages you<br>integrate into your software, the more likely you are to find yourself, one<br>day, in this pit of despair.</p><p>In systems with many dependencies, releasing new package versions can quickly<br>become a nightmare. If the dependency specifications are too tight, you are in<br>danger of version lock (the inability to upgrade a package without having to<br>release new versions of every dependent package). If dependencies are<br>specified too loosely, you will inevitably be bitten by version promiscuity<br>(assuming compatibility with more future versions than is reasonable).<br>Dependency hell is where you are when version lock and/or version promiscuity<br>prevent you from easily and safely moving your project forward.</p><p>As a solution to this problem, I propose a simple set of rules and<br>requirements that dictate how version numbers are assigned and incremented.<br>These rules are based on but not necessarily limited to pre-existing<br>widespread common practices in use in both closed and open-source software.<br>For this system to work, you first need to declare a public API. This may<br>consist of documentation or be enforced by the code itself. Regardless, it is<br>important that this API be clear and precise. Once you identify your public<br>API, you communicate changes to it with specific increments to your version<br>number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not<br>affecting the API increment the patch version, backwards compatible API<br>additions/changes increment the minor version, and backwards incompatible API<br>changes increment the major version.</p><p>I call this system “Semantic Versioning.” Under this scheme, version numbers<br>and the way they change convey meaning about the underlying code and what has<br>been modified from one version to the next.</p><h1 id="Semantic_Versioning_Specification">Semantic Versioning Specification</h1><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,<br>“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be<br>interpreted as described in <a href="http://tools.ietf.org/html/rfc2119" target="_blank" rel="external">RFC 2119</a>.</p><ol><li><p>Software using Semantic Versioning MUST declare a public API. This API<br>could be declared in the code itself or exist strictly in documentation.<br>However it is done, it should be precise and comprehensive.</p></li><li><p>A normal version number MUST take the form X.Y.Z where X, Y, and Z are<br>non-negative integers, and MUST NOT contain leading zeroes. X is the<br>major version, Y is the minor version, and Z is the patch version.<br>Each element MUST increase numerically. For instance: 1.9.0 -&gt; 1.10.0 -&gt; 1.11.0.</p></li><li><p>Once a versioned package has been released, the contents of that version<br>MUST NOT be modified. Any modifications MUST be released as a new version.</p></li><li><p>Major version zero (0.y.z) is for initial development. Anything may change<br>at any time. The public API should not be considered stable.</p></li><li><p>Version 1.0.0 defines the public API. The way in which the version number<br>is incremented after this release is dependent on this public API and how it<br>changes.</p></li><li><p>Patch version Z (x.y.Z | x &gt; 0) MUST be incremented if only backwards<br>compatible bug fixes are introduced. A bug fix is defined as an internal<br>change that fixes incorrect behavior.</p></li><li><p>Minor version Y (x.Y.z | x &gt; 0) MUST be incremented if new, backwards<br>compatible functionality is introduced to the public API. It MUST be<br>incremented if any public API functionality is marked as deprecated. It MAY be<br>incremented if substantial new functionality or improvements are introduced<br>within the private code. It MAY include patch level changes. Patch version<br>MUST be reset to 0 when minor version is incremented.</p></li><li><p>Major version X (X.y.z | X &gt; 0) MUST be incremented if any backwards<br>incompatible changes are introduced to the public API. It MAY include minor<br>and patch level changes. Patch and minor version MUST be reset to 0 when major<br>version is incremented.</p></li><li><p>A pre-release version MAY be denoted by appending a hyphen and a<br>series of dot separated identifiers immediately following the patch<br>version. Identifiers MUST comprise only ASCII alphanumerics and hyphen<br>[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST<br>NOT include leading zeroes. Pre-release versions have a lower<br>precedence than the associated normal version. A pre-release version<br>indicates that the version is unstable and might not satisfy the<br>intended compatibility requirements as denoted by its associated<br>normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,<br>1.0.0-x.7.z.92.</p></li><li><p>Build metadata MAY be denoted by appending a plus sign and a series of dot<br>separated identifiers immediately following the patch or pre-release version.<br>Identifiers MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-].<br>Identifiers MUST NOT be empty. Build metadata SHOULD be ignored when determining<br>version precedence. Thus two versions that differ only in the build metadata,<br>have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,<br>1.0.0-beta+exp.sha.5114f85.</p></li><li><p>Precedence refers to how versions are compared to each other when ordered.<br>Precedence MUST be calculated by separating the version into major, minor, patch<br>and pre-release identifiers in that order (Build metadata does not figure<br>into precedence). Precedence is determined by the first difference when<br>comparing each of these identifiers from left to right as follows: Major, minor,<br>and patch versions are always compared numerically. Example: 1.0.0 &lt; 2.0.0 &lt;<br>2.1.0 &lt; 2.1.1. When major, minor, and patch are equal, a pre-release version has<br>lower precedence than a normal version. Example: 1.0.0-alpha &lt; 1.0.0. Precedence<br>for two pre-release versions with the same major, minor, and patch version MUST<br>be determined by comparing each dot separated identifier from left to right<br>until a difference is found as follows: identifiers consisting of only digits<br>are compared numerically and identifiers with letters or hyphens are compared<br>lexically in ASCII sort order. Numeric identifiers always have lower precedence<br>than non-numeric identifiers. A larger set of pre-release fields has a higher<br>precedence than a smaller set, if all of the preceding identifiers are equal.<br>Example: 1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt;<br>1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0.</p></li></ol><h2 id="Why_Use_Semantic_Versioning?">Why Use Semantic Versioning?</h2><p>This is not a new or revolutionary idea. In fact, you probably do something<br>close to this already. The problem is that “close” isn’t good enough. Without<br>compliance to some sort of formal specification, version numbers are<br>essentially useless for dependency management. By giving a name and clear<br>definition to the above ideas, it becomes easy to communicate your intentions<br>to the users of your software. Once these intentions are clear, flexible (but<br>not too flexible) dependency specifications can finally be made.</p><p>A simple example will demonstrate how Semantic Versioning can make dependency<br>hell a thing of the past. Consider a library called “Firetruck.” It requires a<br>Semantically Versioned package named “Ladder.” At the time that Firetruck is<br>created, Ladder is at version 3.1.0. Since Firetruck uses some functionality<br>that was first introduced in 3.1.0, you can safely specify the Ladder<br>dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when<br>Ladder version 3.1.1 and 3.2.0 become available, you can release them to your<br>package management system and know that they will be compatible with existing<br>dependent software.</p><p>As a responsible developer you will, of course, want to verify that any<br>package upgrades function as advertised. The real world is a messy place;<br>there’s nothing we can do about that but be vigilant. What you can do is let<br>Semantic Versioning provide you with a sane way to release and upgrade<br>packages without having to roll new versions of dependent packages, saving you<br>time and hassle.</p><p>If all of this sounds desirable, all you need to do to start using Semantic<br>Versioning is to declare that you are doing so and then follow the rules. Link<br>to this website from your README so others know the rules and can benefit from<br>them.</p><h2 id="FAQ">FAQ</h2><h3 id="How_should_I_deal_with_revisions_in_the_0-y-z_initial_development_phase?">How should I deal with revisions in the 0.y.z initial development phase?</h3><p>The simplest thing to do is start your initial development release at 0.1.0<br>and then increment the minor version for each subsequent release.</p><h3 id="How_do_I_know_when_to_release_1-0-0?">How do I know when to release 1.0.0?</h3><p>If your software is being used in production, it should probably already be<br>1.0.0. If you have a stable API on which users have come to depend, you should<br>be 1.0.0. If you’re worrying a lot about backwards compatibility, you should<br>probably already be 1.0.0.</p><h3 id="Doesn’t_this_discourage_rapid_development_and_fast_iteration?">Doesn’t this discourage rapid development and fast iteration?</h3><p>Major version zero is all about rapid development. If you’re changing the API<br>every day you should either still be in version 0.y.z or on a separate<br>development branch working on the next major version.</p><h3 id="If_even_the_tiniest_backwards_incompatible_changes_to_the_public_API_require_a_major_version_bump,_won’t_I_end_up_at_version_42-0-0_very_rapidly?">If even the tiniest backwards incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?</h3><p>This is a question of responsible development and foresight. Incompatible<br>changes should not be introduced lightly to software that has a lot of<br>dependent code. The cost that must be incurred to upgrade can be significant.<br>Having to bump major versions to release incompatible changes means you’ll<br>think through the impact of your changes, and evaluate the cost/benefit ratio<br>involved.</p><h3 id="Documenting_the_entire_public_API_is_too_much_work!">Documenting the entire public API is too much work!</h3><p>It is your responsibility as a professional developer to properly document<br>software that is intended for use by others. Managing software complexity is a<br>hugely important part of keeping a project efficient, and that’s hard to do if<br>nobody knows how to use your software, or what methods are safe to call. In<br>the long run, Semantic Versioning, and the insistence on a well defined public<br>API can keep everyone and everything running smoothly.</p><h3 id="What_do_I_do_if_I_accidentally_release_a_backwards_incompatible_change_as_a_minor_version?">What do I do if I accidentally release a backwards incompatible change as a minor version?</h3><p>As soon as you realize that you’ve broken the Semantic Versioning spec, fix<br>the problem and release a new minor version that corrects the problem and<br>restores backwards compatibility. Even under this circumstance, it is<br>unacceptable to modify versioned releases. If it’s appropriate,<br>document the offending version and inform your users of the problem so that<br>they are aware of the offending version.</p><h3 id="What_should_I_do_if_I_update_my_own_dependencies_without_changing_the_public_API?">What should I do if I update my own dependencies without changing the public API?</h3><p>That would be considered compatible since it does not affect the public API.<br>Software that explicitly depends on the same dependencies as your package<br>should have their own dependency specifications and the author will notice any<br>conflicts. Determining whether the change is a patch level or minor level<br>modification depends on whether you updated your dependencies in order to fix<br>a bug or introduce new functionality. I would usually expect additional code<br>for the latter instance, in which case it’s obviously a minor level increment.</p><h3 id="What_if_I_inadvertently_alter_the_public_API_in_a_way_that_is_not_compliant_with_the_version_number_change_(i-e-_the_code_incorrectly_introduces_a_major_breaking_change_in_a_patch_release)">What if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)</h3><p>Use your best judgment. If you have a huge audience that will be drastically<br>impacted by changing the behavior back to what the public API intended, then<br>it may be best to perform a major version release, even though the fix could<br>strictly be considered a patch release. Remember, Semantic Versioning is all<br>about conveying meaning by how the version number changes. If these changes<br>are important to your users, use the version number to inform them.</p><h3 id="How_should_I_handle_deprecating_functionality?">How should I handle deprecating functionality?</h3><p>Deprecating existing functionality is a normal part of software development and<br>is often required to make forward progress. When you deprecate part of your<br>public API, you should do two things: (1) update your documentation to let<br>users know about the change, (2) issue a new minor release with the deprecation<br>in place. Before you completely remove the functionality in a new major release<br>there should be at least one minor release that contains the deprecation so<br>that users can smoothly transition to the new API.</p><h3 id="Does_semver_have_a_size_limit_on_the_version_string?">Does semver have a size limit on the version string?</h3><p>No, but use good judgment. A 255 character version string is probably overkill,<br>for example. Also, specific systems may impose their own limits on the size of<br>the string.</p><h2 id="About">About</h2><p>The Semantic Versioning specification is authored by <a href="http://tom.preston-werner.com" target="_blank" rel="external">Tom<br>Preston-Werner</a>, inventor of Gravatars and<br>cofounder of GitHub.</p><p>If you’d like to leave feedback, please <a href="https://github.com/mojombo/semver/issues" target="_blank" rel="external">open an issue on<br>GitHub</a>.</p><h2 id="License">License</h2><p><a href="http://creativecommons.org/licenses/by/3.0/" target="_blank" rel="external">Creative Commons - CC BY 3.0</a></p></div><div><center><div class="pagination-wrapper"><a class="btn btn-default" href="/tbfe-home/2014/10/17/toc/" class="alignleft prev"><i class="fa fa-chevron-left"></i>上一篇</a> <a class="btn btn-default" href="/tbfe-home/"><i class="fa fa-home"></i>首页</a> <a class="btn btn-default" href="/tbfe-home/2014/10/16/Markdown-Sample/" class="alignright next">下一篇<i class="fa fa-chevron-right"></i></a></div></center></div><section id="comment"><div class="ds-thread" data-thread-key="_posts/2014-10-16-Semver-2-0-0.md" data-title="Semver 2.0.0" data-url="http://wayou.github.io/2014/10/16/Semver-2-0-0/"></div><script type="text/javascript">var duoshuoQuery={short_name:"tbfe"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}();</script></section></div><div class="col-md-3"><div id="toc"></div></div></div></div></div><div class="container-narrow"><footer><p><i class="icon-material-keyboard-arrow-left" style="font-size: 10pt"></i>/<i class="icon-material-keyboard-arrow-right" style="font-size: 10pt"></i> with <i class="icon icon-material-favorite icon-material-red" style="font-size: 10pt"></i> by tieba fe internal team with the help of <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a></p><p>&copy; 2014 <a href="http://wayou.github.io">JSBear Team</a></p></footer></div><a id="gotop" href="#"><i class="fa fa-chevron-circle-up"></i></a><script src="/tbfe-home/js/jquery.imagesloaded.min.js"></script><script src="/tbfe-home/js/gallery.js"></script><script src="/tbfe-home/js/bootstrap.min.js"></script><script src="/tbfe-home/material/js/ripples.js"></script><script src="/tbfe-home/material/js/material.js"></script><script src="/tbfe-home/js/jqueryui.js"></script><script src="/tbfe-home/js/jquery.tocify.js"></script><script src="/tbfe-home/js/main.js"></script></body></html>